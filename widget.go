package windigo

import (
	"errors"
	"reflect"
	"unsafe"

	termbox "github.com/nsf/termbox-go"
)

type Widget interface {
	// MapEvent is called by (is?) the widget's StateFunctions to
	// determine state trasitions.
	Map(*Region, *termbox.Event, FiniteState) interface{}
	// A widget's Init() function will set up the widget's
	// behavior, calling ReqFocus or RegClickable and
	// setting up the widget's InputChan.
	//Init(...Sigil) error
}

// Widgets accept input Events from the screen's InputEventRouter
// and generate their own Event sending it down it's eventchan[0]
// channel where its container's EventMgr is waiting for it.
// Input events are handled by the windigo main screen's InputEventRouter
// which first finds any objects interested in receiving particular
// types of events from particular absolute coordinates and channels
// them to the the object(widget) that registered interest via it's own
// virtual coordinates.  Gadgets handle Events generated by their
// widgets.
type WidgetType struct {
	// A widgets location within its containing gadget/window
	TopLeft
	// A widgets size
	WidthHeight
	MinSize WidthHeight

	Color

	allowFocus bool
	haveFocus  bool
	// kbd is an index into inputchan. kbd == -1 if no keyboard/focus.
	kbd       int
	InputChan []chan *termbox.Event

	Comm []IChing

	Fsm *FiniteStateMachine

	BackingStore []Cell

	Elastic ElasticType
	Gravity GravityType
	// If a widget's EventMgr requires further input, it
	// should create a new widget in the widget's EventMgr,
	// setting that widget's oneshot variable to true.  widget's
	// created by other widgets require display in another objects
	// screen space.  They don't fit and are promoted either until
	// they do fit, or they return an error (they don't fit on the
	// top level screen.)  Promoted widgets must have oneshot set to
	// true.  This is done using the widget's SetOneshot method.
	// A oneshot widget steals focus and must be attended or
	// dismissed.  Promotion has the side effect of keeping the oneshot
	// or "popup" geographically close to the widget that produced it.
	oneshot bool
	managed bool

	// Our container.
	Parent Container
}

type Sigil []Cell

func NewWidget(r *Region, activeStates ...Sigil) (*WidgetType, error) {
	/*
		if len(activeStates) == 0 {
			err := errors.New("widget must have at least one active state")
			return nil, err
		}
	*/

	//sigil := activeStates[0]
	w := new(WidgetType)
	w.X = r.X
	w.Y = r.Y
	w.W = r.W
	w.H = r.H
	//w.Fg = sigil[0].Fg
	//w.Bg = sigil[0].Bg
	//w.Fsm = NewFSM(activeStates...)
	return w, nil
}

func (w *WidgetType) Loc() (int, int) {
	return w.X, w.Y
}

func (w *WidgetType) SetLoc(x, y int) {
	w.X = x
	w.Y = y
}

func (w *WidgetType) Size() (int, int) {
	return w.W, w.H
}

func (w *WidgetType) SetSize(width, height int) {
	w.W = width
	w.H = height
}

func (w *WidgetType) Colors() (Attribute, Attribute) {
	return w.Fg, w.Bg
}

func (w *WidgetType) SetColors(fg, bg Attribute) {
	w.Fg = fg
	w.Bg = bg
}

func (w *WidgetType) Ancestor() Container {
	return w.Parent
}

func (w *WidgetType) SetAncestor(p Container) {
	w.Parent = p
}

func (w *WidgetType) HaveFocus() bool {
	return w.haveFocus
}

func (w *WidgetType) SetHaveFocus(f bool) {
	w.haveFocus = f
}

func (w *WidgetType) AllowFocus() bool {
	return w.allowFocus
}

func (w *WidgetType) SetAllowFocus(f bool) {
	w.allowFocus = f
}

func (w *WidgetType) Managed() bool {
	return w.managed
}

func (w *WidgetType) SetManaged() {
	w.managed = true
}

func (w *WidgetType) Init() error {
	return nil
}

func (w *WidgetType) AddComm(c IChing) {
	w.Comm = append(w.Comm, c)
}

func (w *WidgetType) GetComm() []IChing {
	return w.Comm
}

func (w *WidgetType) PushEvent(e *Event) {
	w.Comm[0].Yang <- e
}

func (w *WidgetType) PollEvent() *termbox.Event {

	channels := w.InputChan
	n := len(channels)

	var selectCase = make([]reflect.SelectCase, n)

	for i := 0; i < n; i++ {
		selectCase[i].Dir = reflect.SelectRecv
		selectCase[i].Chan = reflect.ValueOf(channels[i])
	}

	_, recv, recvOk := reflect.Select(selectCase)
	if recvOk {
		ev := *(*termbox.Event)(unsafe.Pointer(recv.Pointer()))
		return &ev
	}
	return nil
}

func (w *WidgetType) Clear() {
	Fill(w, ' ')
}

func (w *WidgetType) ReqFocus() (chan *termbox.Event, error) {
	var channel chan *termbox.Event = nil
	var err error = nil

	havefocus := w.haveFocus
	allowfocus := w.allowFocus
	kbd := w.kbd
	channels := w.InputChan
	n := len(channels)

	if havefocus {
		if kbd < 0 || kbd >= n {
			err := errors.New("kbd input channel error")
			return nil, err
		}
		return channels[kbd], nil
	}
	if !havefocus && allowfocus {
		channel, _ = screen.RequestFocus()
		if channel != nil {
			w.InputChan = append(w.InputChan, channel)
			w.kbd = n
			w.haveFocus = true
		}
	}
	return channel, err
}

func (w *WidgetType) AddInput(c chan *termbox.Event) {
	w.InputChan = append(w.InputChan, c)
}

func (w *WidgetType) InputEventMgr() {

	//channels := w.InputChannels()
	channels := w.InputChan
	n := len(channels)
	fsm := w.Fsm
	if n == 0 || fsm == nil {
		return
	}

	ev := new(termbox.Event)
	ev.Type = termbox.EventNone

	// Upon initialization, state should be ENTRY (0), and the
	// widget initialization should take place in the statefunc[ENTRY]
	// which should then advance the state to the first Active state
	// (usually by returning Ok.)  The transition table should contain
	// an entry like {ENTRY, Ok, ACTIVE} where ACTIVE is the first/
	// default(possibly only) active state.
	// Entering the EXIT state will cause the eventmgr for that
	// widget to exit.
loop:
	for {
		// State functions test termbox input events like
		// ev.Key == termbox.MouseLeft and coordinates
		// and return Ok, Fail, or Repeat.
		// The FSM for a widget should be initialized by the
		// function that creates the widget, i.e. NewScrollBar().
		Func := fsm.StateFunc[fsm.CurrentState]
		wev := Func(ev)
		// widgets will send event to container whenever
		// the state function returns Ok or Repeat.
		if wev.Result.Rc == Fail {
			e := WidgetResult(Fail, "Widget state machine returned Fail")
			err := errors.New("InputEventMgr: fsm returns Fail")
			_ = err
			w.PushEvent(e)
		}
		if wev.Result.Rc != Fail && wev.Result.Rc != Nop {
			w.PushEvent(wev)
		}
		if fsm.CurrentState == fsm.ExitState {
			err := errors.New("exiting FSM")
			_ = err
			break loop
		}
		fsm.CurrentState, _ = fsm.NextState(wev.Result.Rc)
		ev = w.PollEvent()
	}
}

/*
func EventMgr(w Widget) {
	// Wait for events on w.yin and process them.
	// These events might be Move or Resize.
	// These events are NOT part of the widget's Finite
	// State Machine, but may cause state changes if the
	// event is something like Reset/Init.
loop:
	for {
		//
		//
		yin, _ := Yin(w)
		switch wev := <-yin; wev.EventType {
		case Reset:
			fsm := FSM(w)
			fsm.SetState(fsm.EntryState)
		case Exit:
			break loop
		default:
		}
	}
}
*/

func (w *WidgetType) SetFSM(fsm *FiniteStateMachine) {
	w.Fsm = fsm
}

func (w *WidgetType) Start() {
	//go w.EventMgr()
	go w.InputEventMgr()
	Flush()
}

/*
func (w *WidgetType) Press(ms time.Duration) {
	w.Wprint(w.X, w.X, w.Fsm.state[w.state].fg|AttrBold,
		w.fsm.state[w.state].bg, w.fsm.state[w.state].icon)
	Flush()
	time.Sleep(time.Millisecond * ms)
	w.Wprint(w.X, w.Y, w.fsm.state[w.state].fg,
		w.fsm.state[w.state].bg, w.fsm.state[w.state].icon)

	Flush()
}
*/

func String2Sigil(s string, fg, bg Attribute) *Sigil {

	sigil := new(Sigil)
	runes := []rune(s)

	for _, r := range runes {
		*sigil = append(*sigil, Cell{Ch: r, Fg: fg, Bg: bg})
	}

	return sigil
}

func (widget *WidgetType) Refresh() {

	if !widget.Managed() {
		return
	}

	//x, y := widget.Loc()
	w, h := widget.Size()

	fsm := widget.Fsm
	if fsm != nil {
		state := fsm.CurrentState
		s := fsm.Sigil[state]

		for i := 0; i < w; i++ {
			for j := 0; j < h; j++ {
				SetCell(widget, i, j, s[i*j].Ch, s[i*j].Fg, s[i*j].Bg)
			}
		}
	}
}
